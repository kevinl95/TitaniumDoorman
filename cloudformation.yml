AWSTemplateFormatVersion: "2010-09-09"
Description: Hardware-less Video Doorbell â€” TiDB AgentX Hackathon Stack

Parameters:
  TiDBConnectionString:
    Type: String
    NoEcho: true
    Description: "TiDB connection string - copy from TiDB Cloud console (e.g., mysql://username.root:password@gateway01.us-east-1.prod.aws.tidbcloud.com:4000/test where 'test' is your database name)"
  NotificationPhone:
    Type: String
    Description: "Resident phone number for SMS notifications (format: +12345678901 - include country code)"

Resources:
  ### S3 Static Website ###
  VisitorWebsiteBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AWS::StackName}-${AWS::AccountId}-${AWS::Region}"
      WebsiteConfiguration:
        IndexDocument: index.html
      PublicAccessBlockConfiguration:
        BlockPublicAcls: false
        BlockPublicPolicy: false
        IgnorePublicAcls: false
        RestrictPublicBuckets: false

  VisitorWebsiteBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref VisitorWebsiteBucket
      PolicyDocument:
        Statement:
          - Effect: Allow
            Principal: "*"
            Action: s3:GetObject
            Resource: !Sub "arn:aws:s3:::${VisitorWebsiteBucket}/*"

  WebsiteDeployerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:DeleteObject
                Resource: !Sub 'arn:aws:s3:::${VisitorWebsiteBucket}/*'

  WebsiteDeployerLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-website-deployer"
      Handler: index.handler
      Runtime: python3.11
      Timeout: 300
      Role: !GetAtt WebsiteDeployerRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import base64
          import io
          
          def handler(event, context):
              try:
                  s3 = boto3.client('s3')
                  bucket = event['ResourceProperties']['Bucket']
                  api_url = event['ResourceProperties']['ApiUrl']
                  
                  html_content = f'''<!DOCTYPE html>
          <html>
          <head>
              <title>Virtual Doorman</title>
              <meta name="viewport" content="width=device-width, initial-scale=1">
              <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
              <style>
                  body {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; }}
                  .chat-container {{ background: white; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }}
                  .chat-messages {{ height: 350px; overflow-y: auto; background: #f8f9fa; border-radius: 10px; }}
                  .message {{ margin: 8px 0; padding: 12px 16px; border-radius: 18px; max-width: 80%; }}
                  .user {{ background: #007bff; color: white; margin-left: auto; text-align: right; }}
                  .agent {{ background: #e9ecef; color: #333; }}
                  .chat-header {{ background: #007bff; color: white; border-radius: 15px 15px 0 0; }}
                  .btn-send {{ background: #007bff; border: none; border-radius: 25px; }}
                  .btn-send:hover {{ background: #0056b3; }}
                  .form-control {{ border-radius: 25px; }}
              </style>
          </head>
          <body>
              <div class="container py-4">
                  <div class="row justify-content-center">
                      <div class="col-md-6 col-lg-5">
                          <div class="chat-container">
                              <div class="chat-header p-4 text-center">
                                  <h3 class="mb-1">Virtual Doorman</h3>
                                  <p class="mb-0 opacity-75">Hello! I'm here to help. How can I assist you today?</p>
                              </div>
                              <div class="p-4">
                                  <div id="chat" class="chat-messages p-3 mb-3"></div>
                                  <div class="mb-3">
                                      <input type="text" id="nameInput" class="form-control" placeholder="Your name (optional)" />
                                  </div>
                                  <div class="input-group">
                                      <input type="text" id="messageInput" class="form-control" placeholder="Type your message..." />
                                      <button class="btn btn-send px-4" onclick="sendMessage()">Send</button>
                                  </div>
                              </div>
                          </div>
                      </div>
                  </div>
              </div>
              <script>
                  const API_URL = '{api_url}';
                  let sessionToken = null;
                  async function initSession() {{
                      try {{
                          const response = await fetch(API_URL + '/doorbell', {{
                              method: 'POST',
                              headers: {{'Content-Type': 'application/json'}},
                              body: JSON.stringify({{visitor_name: document.getElementById('nameInput').value || 'Anonymous'}})
                          }});
                          const data = await response.json();
                          sessionToken = data.session_token;
                      }} catch (error) {{
                          console.error('Session init failed:', error);
                      }}
                  }}
                  async function sendMessage() {{
                      const messageInput = document.getElementById('messageInput');
                      const message = messageInput.value.trim();
                      if (!message) return;
                      if (!sessionToken) await initSession();
                      addMessage(message, 'user');
                      messageInput.value = '';
                      try {{
                          const response = await fetch(API_URL + '/agent', {{
                              method: 'POST',
                              headers: {{'Content-Type': 'application/json'}},
                              body: JSON.stringify({{session_token: sessionToken, message: message}})
                          }});
                          const data = await response.json();
                          addMessage(data.response, 'agent');
                      }} catch (error) {{
                          addMessage('Sorry, I encountered an error. Please try again.', 'agent');
                      }}
                  }}
                  function addMessage(text, sender) {{
                      const chat = document.getElementById('chat');
                      const div = document.createElement('div');
                      div.className = 'message ' + sender + ' d-flex';
                      div.textContent = text;
                      chat.appendChild(div);
                      chat.scrollTop = chat.scrollHeight;
                  }}
                  document.getElementById('messageInput').addEventListener('keypress', function(e) {{
                      if (e.key === 'Enter') sendMessage();
                  }});
              </script>
          </body>
          </html>'''
                  
                  if event['RequestType'] == 'Delete':
                      s3.delete_object(Bucket=bucket, Key='index.html')
                      try:
                          s3.delete_object(Bucket=bucket, Key='qr-code.png')
                      except:
                          pass
                  else:
                      # Deploy HTML
                      s3.put_object(
                          Bucket=bucket,
                          Key='index.html',
                          Body=html_content,
                          ContentType='text/html'
                      )
                      
                      # Generate simple QR code using ASCII art
                      website_url = f'http://{bucket}.s3-website-{boto3.Session().region_name}.amazonaws.com'
                      qr_html = f'''<!DOCTYPE html>
          <html>
          <head>
              <title>Virtual Doorbell - Scan to Ring</title>
              <style>
                  body {{ font-family: Arial, sans-serif; text-align: center; padding: 20px; background: #f8f9fa; }}
                  .container {{ background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); max-width: 400px; margin: 0 auto; }}
                  .qr-container {{ margin: 30px auto; }}
                  .instructions {{ margin: 20px 0; color: #333; }}
                  .url {{ word-break: break-all; margin: 20px; font-size: 12px; color: #666; }}
                  h1 {{ color: #007bff; margin-bottom: 10px; }}
                  .subtitle {{ color: #666; margin-bottom: 20px; }}
              </style>
          </head>
          <body>
              <div class="container">
                  <h1>Virtual Doorbell</h1>
                  <p class="subtitle">Welcome! The resident uses a smart doorbell system.</p>
                  
                  <div class="instructions">
                      <p><strong>To ring the doorbell:</strong></p>
                      <p>1. Scan this QR code with your phone camera</p>
                      <p>2. Tell the virtual doorman why you're visiting</p>
                      <p>3. The resident will be notified instantly!</p>
                  </div>
                  
                  <div class="qr-container">
                      <img src="https://api.qrserver.com/v1/create-qr-code/?size=250x250&data={website_url}" alt="QR Code to ring doorbell" />
                  </div>
                  
                  <div class="url">
                      <p>Or visit: <a href="{website_url}">{website_url}</a></p>
                  </div>
              </div>
          </body>
          </html>'''
                      
                      s3.put_object(
                          Bucket=bucket,
                          Key='qr.html',
                          Body=qr_html,
                          ContentType='text/html'
                      )
                  
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              except Exception as e:
                  print(f'Error: {{str(e)}}')
                  import traceback
                  traceback.print_exc()
                  cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)})
                  raise

  DeployWebsite:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt WebsiteDeployerLambda.Arn
      Bucket: !Ref VisitorWebsiteBucket
      ApiUrl: !Sub 'https://${DoorbellApi}.execute-api.${AWS::Region}.amazonaws.com/prod'

  ### Secrets Manager ###
  TiDBSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub "${AWS::StackName}-tidb-credentials"
      Description: "TiDB credentials for the Hardware-less Video Doorbell agent"
      SecretString:
        !Sub |
          {
            "connection_string": "${TiDBConnectionString}"
          }

  ### SNS Topic for notifications ###
  DoorbellTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: "DoorbellNotifications"

  DoorbellTopicSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      TopicArn: !Ref DoorbellTopic
      Protocol: sms
      Endpoint: !Ref NotificationPhone

  ### IAM Role for Lambdas ###
  DoorbellLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DoorbellLambdaPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: !Ref TiDBSecret
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource: !Ref DoorbellTopic
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                Resource: !Sub "arn:aws:bedrock:${AWS::Region}::foundation-model/amazon.titan-text-g1-express"



  ### Lambdas ###
  SessionInitLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-session-init"
      Handler: index.handler
      Runtime: python3.11
      Timeout: 60
      Role: !GetAtt DoorbellLambdaRole.Arn
      Environment:
        Variables:
          SNS_TOPIC_ARN: !Ref DoorbellTopic
          TIDB_SECRET_ARN: !Ref TiDBSecret
      Layers:
        - arn:aws:lambda:us-east-1:770693421928:layer:Klayers-p311-pymysql:3
      Code:
        ZipFile: |
          import json
          import boto3
          import uuid
          import pymysql
          import ssl
          import os
          
          def get_tidb_connection():
              secrets_client = boto3.client('secretsmanager')
              secret = secrets_client.get_secret_value(SecretId=os.environ['TIDB_SECRET_ARN'])
              creds = json.loads(secret['SecretString'])
              
              # Parse connection string: mysql://user:pass@host:port/db
              conn_str = creds['connection_string']
              import re
              match = re.match(r'mysql://([^:]+):([^@]+)@([^:]+):([^/]+)/(.+)', conn_str)
              if not match:
                  raise ValueError('Invalid connection string format')
              
              user, password, host, port, database = match.groups()
              
              ssl_ctx = ssl.create_default_context()
              ssl_ctx.check_hostname = True
              ssl_ctx.verify_mode = ssl.CERT_REQUIRED
              
              return pymysql.connect(
                  host=host,
                  port=int(port),
                  user=user,
                  password=password,
                  database=database,
                  ssl=ssl_ctx,
                  autocommit=True
              )
          
          def init_schema(conn):
              with conn.cursor() as cursor:
                  cursor.execute("""
                      CREATE TABLE IF NOT EXISTS visitors (
                          visitor_id VARCHAR(36) PRIMARY KEY,
                          canonical_name VARCHAR(255),
                          phone VARCHAR(50),
                          email VARCHAR(255),
                          metadata JSON,
                          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
                      )
                  """)
                  
                  cursor.execute("""
                      CREATE TABLE IF NOT EXISTS visits (
                          visit_id VARCHAR(36) PRIMARY KEY,
                          visitor_id VARCHAR(36),
                          session_token VARCHAR(36) UNIQUE,
                          visitor_name VARCHAR(255),
                          message TEXT,
                          intent VARCHAR(50),
                          response TEXT,
                          status VARCHAR(20) DEFAULT 'active',
                          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                      )
                  """)
          
          def handler(event, context):
              try:
                  body = json.loads(event['body']) if event.get('body') else {}
                  visitor_name = body.get('visitor_name', 'Anonymous')
                  session_token = str(uuid.uuid4())
                  visit_id = str(uuid.uuid4())
                  
                  conn = get_tidb_connection()
                  init_schema(conn)
                  
                  with conn.cursor() as cursor:
                      cursor.execute(
                          "INSERT INTO visits (visit_id, session_token, visitor_name, status) VALUES (%s, %s, %s, %s)",
                          (visit_id, session_token, visitor_name, 'initiated')
                      )
                  
                  conn.close()
                  print(f"Session created: {session_token} for {visitor_name}")
                  
                  return {
                      'statusCode': 200,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type',
                          'Access-Control-Allow-Methods': 'POST, OPTIONS'
                      },
                      'body': json.dumps({
                          'session_token': session_token,
                          'message': 'Session created successfully'
                      })
                  }
              except Exception as e:
                  print(f"Error: {str(e)}")
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': json.dumps({'error': str(e)})
                  }

  AgentOrchestratorLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-agent-orchestrator"
      Handler: index.handler
      Runtime: python3.11
      Timeout: 120
      Role: !GetAtt DoorbellLambdaRole.Arn
      Environment:
        Variables:
          SNS_TOPIC_ARN: !Ref DoorbellTopic
          TIDB_SECRET_ARN: !Ref TiDBSecret
      Layers:
        - arn:aws:lambda:us-east-1:770693421928:layer:Klayers-p311-pymysql:3
      Code:
        ZipFile: |
          import json
          import boto3
          import pymysql
          import ssl
          import os
          from datetime import datetime, timedelta
          
          def get_tidb_connection():
              secrets_client = boto3.client('secretsmanager')
              secret = secrets_client.get_secret_value(SecretId=os.environ['TIDB_SECRET_ARN'])
              creds = json.loads(secret['SecretString'])
              
              # Parse connection string: mysql://user:pass@host:port/db
              conn_str = creds['connection_string']
              import re
              match = re.match(r'mysql://([^:]+):([^@]+)@([^:]+):([^/]+)/(.+)', conn_str)
              if not match:
                  raise ValueError('Invalid connection string format')
              
              user, password, host, port, database = match.groups()
              
              ssl_ctx = ssl.create_default_context()
              ssl_ctx.check_hostname = True
              ssl_ctx.verify_mode = ssl.CERT_REQUIRED
              
              return pymysql.connect(
                  host=host,
                  port=int(port),
                  user=user,
                  password=password,
                  database=database,
                  ssl=ssl_ctx,
                  autocommit=True
              )
          
          def classify_visitor_intent_with_ai(message, historical_context=""):
              bedrock = boto3.client('bedrock-runtime')
              
              prompt = f"Classify this doorbell visitor message into one category: delivery, friend, solicitor, service, emergency, or unknown.\n\nVisitor message: '{message}'\n{f'Previous visits: {historical_context}' if historical_context else ''}\n\nRespond with only the category name (lowercase)."
              
              try:
                  response = bedrock.invoke_model(
                      modelId='amazon.titan-text-g1-express',
                      body=json.dumps({
                          'inputText': prompt,
                          'textGenerationConfig': {
                              'maxTokenCount': 10,
                              'temperature': 0.1
                          }
                      })
                  )
                  
                  result = json.loads(response['body'].read())
                  intent = result['results'][0]['outputText'].strip().lower()
                  
                  # Validate intent
                  valid_intents = ['delivery', 'friend', 'solicitor', 'service', 'emergency', 'unknown']
                  return intent if intent in valid_intents else 'unknown'
                  
              except Exception as e:
                  print(f"Bedrock error: {e}")
                  # Fallback to keyword classification
                  message_lower = message.lower()
                  if any(word in message_lower for word in ['delivery', 'package', 'mail']):
                      return 'delivery'
                  elif any(word in message_lower for word in ['friend', 'visit']):
                      return 'friend'
                  return 'unknown'
          
          def generate_ai_response(intent, visitor_name, message, has_history=False):
              bedrock = boto3.client('bedrock-runtime')
              
              context = "returning visitor" if has_history else "first-time visitor"
              
              prompt = f"You are a virtual doorman speaking TO a visitor at the door. The visitor just told you: '{message}'. Respond directly to the visitor to acknowledge their message and let them know you're notifying the resident. Be brief and professional.\n\nVisit type: {intent}\nVisitor: {visitor_name}\nContext: {context}"
              
              try:
                  response = bedrock.invoke_model(
                      modelId='amazon.titan-text-g1-express',
                      body=json.dumps({
                          'inputText': prompt,
                          'textGenerationConfig': {
                              'maxTokenCount': 100,
                              'temperature': 0.3
                          }
                      })
                  )
                  
                  result = json.loads(response['body'].read())
                  return result['results'][0]['outputText'].strip()
                  
              except Exception as e:
                  print(f"Bedrock error: {e}")
                  # Fallback responses
                  responses = {
                      'delivery': "Thank you! I'll let the resident know about your delivery.",
                      'friend': "Hello! I'll notify the resident that you're here.",
                      'solicitor': "Thank you for stopping by. The resident isn't available for solicitations at this time.",
                      'service': "I'll inform the resident about your service visit right away.",
                      'emergency': "I understand this is urgent. I'm notifying the resident immediately!",
                      'unknown': "Thank you for your message. I'm letting the resident know you're here."
                  }
                  return responses.get(intent, responses['unknown'])
          
          def search_historical_visits(conn, visitor_name, intent):
              with conn.cursor() as cursor:
                  # Search for similar visits in the last 30 days
                  cursor.execute(
                      "SELECT visitor_name, intent, message, created_at FROM visits WHERE (visitor_name LIKE %s OR intent = %s) AND created_at > %s ORDER BY created_at DESC LIMIT 5",
                      (f"%{visitor_name}%", intent, datetime.now() - timedelta(days=30))
                  )
                  return cursor.fetchall()
          
          def handler(event, context):
              try:
                  body = json.loads(event['body'])
                  session_token = body['session_token']
                  message = body['message']
                  
                  conn = get_tidb_connection()
                  
                  # Get visitor info from session
                  with conn.cursor() as cursor:
                      cursor.execute("SELECT visitor_name FROM visits WHERE session_token = %s", (session_token,))
                      result = cursor.fetchone()
                      visitor_name = result[0] if result else 'Anonymous'
                  
                  # Search for historical visits first
                  historical_visits = search_historical_visits(conn, visitor_name, "")
                  
                  # Build context for AI
                  history_context = ""
                  if historical_visits:
                      recent_intents = [visit[1] for visit in historical_visits[:3] if visit[1]]
                      history_context = f"Recent visits: {', '.join(recent_intents)}"
                  
                  # AI-powered intent classification
                  intent = classify_visitor_intent_with_ai(message, history_context)
                  
                  # AI-generated response
                  response_text = generate_ai_response(intent, visitor_name, message, len(historical_visits) > 0)
                  
                  # Update visit record
                  with conn.cursor() as cursor:
                      cursor.execute(
                          "UPDATE visits SET message = %s, intent = %s, response = %s, status = 'processed' WHERE session_token = %s",
                          (message, intent, response_text, session_token)
                      )
                  
                  conn.close()
                  
                  # Send SNS notification with context
                  sns = boto3.client('sns')
                  topic_arn = os.environ['SNS_TOPIC_ARN']
                  
                  history_context = f"\n\nRecent visits: {len(historical_visits)}" if historical_visits else "\n\nFirst-time visitor"
                  
                  sns.publish(
                      TopicArn=topic_arn,
                      Subject=f"Doorbell Visit - {intent.title()}",
                      Message=f"Visitor: {visitor_name}\nMessage: {message}\n\nClassified as: {intent.upper()}\nSession ID: {session_token}{history_context}"
                  )
                  
                  return {
                      'statusCode': 200,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type',
                          'Access-Control-Allow-Methods': 'POST, OPTIONS'
                      },
                      'body': json.dumps({
                          'response': response_text,
                          'intent': intent,
                          'historical_visits': len(historical_visits) if historical_visits else 0
                      })
                  }
              except Exception as e:
                  print(f"Error: {str(e)}")
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': json.dumps({'error': str(e)})
                  }

  ### API Gateway ###
  DoorbellApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: DoorbellAPI
      EndpointConfiguration:
        Types: [REGIONAL]

  # Doorbell endpoint
  DoorbellApiResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref DoorbellApi
      ParentId: !GetAtt DoorbellApi.RootResourceId
      PathPart: "doorbell"

  DoorbellApiMethodSession:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref DoorbellApi
      ResourceId: !Ref DoorbellApiResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub
          arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SessionInitLambda.Arn}/invocations

  DoorbellApiMethodOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref DoorbellApi
      ResourceId: !Ref DoorbellApiResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  # Agent endpoint
  AgentApiResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref DoorbellApi
      ParentId: !GetAtt DoorbellApi.RootResourceId
      PathPart: "agent"

  AgentApiMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref DoorbellApi
      ResourceId: !Ref AgentApiResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub
          arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${AgentOrchestratorLambda.Arn}/invocations

  AgentApiMethodOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref DoorbellApi
      ResourceId: !Ref AgentApiResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  DoorbellApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn: 
      - DoorbellApiMethodSession
      - DoorbellApiMethodOptions
      - AgentApiMethod
      - AgentApiMethodOptions
    Properties:
      RestApiId: !Ref DoorbellApi
      StageName: prod

  ### Lambda Permissions for API Gateway ###
  SessionInitLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref SessionInitLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${DoorbellApi}/*/POST/doorbell"

  AgentOrchestratorLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref AgentOrchestratorLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${DoorbellApi}/*/POST/agent"

Outputs:
  VisitorWebsiteUrl:
    Description: "Visitor website URL - use this for QR code"
    Value: !Sub "http://${VisitorWebsiteBucket}.s3-website-${AWS::Region}.amazonaws.com"

  QRCodeUrl:
    Description: "QR Code page - open this to print QR code for your door"
    Value: !Sub "http://${VisitorWebsiteBucket}.s3-website-${AWS::Region}.amazonaws.com/qr.html"

  ApiInvokeUrl:
    Description: "Base URL for Doorbell API"
    Value: !Sub "https://${DoorbellApi}.execute-api.${AWS::Region}.amazonaws.com/prod"

  SnsTopicArn:
    Description: "SNS Topic for notifications"
    Value: !Ref DoorbellTopic

  TiDBSecretArn:
    Description: "ARN of the TiDB credentials secret"
    Value: !Ref TiDBSecret
